import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import random

# 设置中文字体支持 (根据系统环境自动回退)
plt.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS', 'DejaVu Sans']
plt.rcParams['axes.unicode_minus'] = False

class VOSviewerSim:
    def __init__(self):
        # VOSviewer 经典配色方案 (红, 绿, 蓝, 黄)
        self.colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00']
        # 黑色背景风格
        self.bg_color = '#111111'
        self.text_color = '#EEEEEE'

    def setup_plot(self, title):
        fig, ax = plt.subplots(figsize=(12, 9))
        fig.patch.set_facecolor(self.bg_color)
        ax.set_facecolor(self.bg_color)
        ax.set_title(title, color=self.text_color, fontsize=16, pad=20)
        ax.axis('off')
        return fig, ax

    def draw_network(self, G, pos, node_colors, node_sizes, labels, ax):
        # 绘制边 (带透明度，模拟密集网络)
        for (u, v, d) in G.edges(data=True):
            weight = d.get('weight', 1)
            alpha = min(0.6, 0.1 + weight * 0.05)
            # 边的颜色取源节点的颜色，稍微暗淡一点
            edge_color = node_colors[list(G.nodes()).index(u)]
            nx.draw_networkx_edges(G, pos, edgelist=[(u, v)], width=weight*0.5, 
                                   alpha=alpha, edge_color=edge_color, ax=ax, arrows=False)

        # 绘制节点 (光晕效果)
        # 外圈 (模拟发光)
        nx.draw_networkx_nodes(G, pos, node_size=[s * 1.5 for s in node_sizes], 
                               node_color=node_colors, alpha=0.3, ax=ax, linewidths=0)
        # 内圈 (实心)
        nx.draw_networkx_nodes(G, pos, node_size=node_sizes, 
                               node_color=node_colors, alpha=0.9, ax=ax, linewidths=0)

        # 绘制标签
        for node, (x, y) in pos.items():
            size = G.nodes[node]['size']
            font_size = 8 + (size / 100) # 根据节点大小动态调整字号
            ax.text(x, y+0.04, node, fontsize=font_size, color=self.text_color, 
                    ha='center', va='bottom', fontweight='bold',
                    bbox=dict(facecolor=self.bg_color, alpha=0.6, edgecolor='none', boxstyle='round,pad=0.1'))

    def generate_keyword_map(self):
        """生成关键词共现图 (Co-occurrence)"""
        fig, ax = self.setup_plot("VOSviewer Output 1: Keyword Co-occurrence Network\n(Evolution: Physics -> Data -> Carbon)")
        
        # 定义聚类数据
        # Cluster 1 (Red): 物理建模基础
        c1 = ["UBEM", "EnergyPlus", "CityGML", "GIS", "LOD", "Thermal Model", "Solar Radiation"]
        # Cluster 2 (Green): 数据驱动与感知
        c2 = ["Machine Learning", "Calibration", "Data-Driven", "Urban Sensing", "IoT", "Smart Meter", "Neural Networks"]
        # Cluster 3 (Blue): 碳中和与应用
        c3 = ["Carbon Neutrality", "Digital Twin", "Retrofit", "Decarbonization", "Resilience", "PV Potential", "Grid Interaction"]
        
        G = nx.Graph()
        node_colors = []
        node_sizes = []
        
        # 构建节点
        all_nodes = c1 + c2 + c3
        cluster_map = {n: 0 for n in c1}
        cluster_map.update({n: 1 for n in c2})
        cluster_map.update({n: 2 for n in c3})
        
        for i, node in enumerate(all_nodes):
            # 模拟节点权重 (频率)
            weight = random.randint(30, 150)
            if node in ["UBEM", "Carbon Neutrality", "Digital Twin", "Machine Learning"]:
                weight += 150 # 核心词更大
            
            G.add_node(node, size=weight, group=cluster_map[node])
            node_colors.append(self.colors[cluster_map[node]])
            node_sizes.append(weight * 3)

        # 构建边 (模拟共现关系)
        # 聚类内部连接紧密
        for cluster in [c1, c2, c3]:
            for i in range(len(cluster)):
                for j in range(i + 1, len(cluster)):
                    if random.random() > 0.4:
                        G.add_edge(cluster[i], cluster[j], weight=random.randint(1, 5))
        
        # 聚类之间连接 (体现演变)
        connections = [
            ("EnergyPlus", "Calibration"), ("CityGML", "Digital Twin"), 
            ("GIS", "Urban Sensing"), ("Machine Learning", "Retrofit"),
            ("Data-Driven", "Carbon Neutrality"), ("UBEM", "Grid Interaction")
        ]
        for u, v in connections:
            G.add_edge(u, v, weight=random.randint(3, 8))

        pos = nx.spring_layout(G, k=0.4, iterations=50, seed=42)
        self.draw_network(G, pos, node_colors, node_sizes, all_nodes, ax)
        plt.tight_layout()
        plt.savefig('vosviewer_keyword_map.png', dpi=300, facecolor=self.bg_color)

    def generate_collaboration_map(self):
        """生成国家/机构合作网络图 (Collaboration Network)"""
        fig, ax = self.setup_plot("VOSviewer Output 2: Country/Institution Collaboration Network")
        
        # 节点：国家 (大) 和 机构 (小)
        countries = {
            "USA": ["NREL", "LBNL", "MIT", "Georgia Tech"],
            "China": ["Tsinghua Univ", "Tongji Univ", "Hong Kong PolyU", "Tianjin Univ"],
            "Europe": ["ETH Zurich", "UCL", "TU Delft", "RWTH Aachen"],
            "Others": ["NUS", "Ryerson Univ"]
        }
        
        G = nx.Graph()
        node_colors = []
        node_sizes = []
        labels = []
        
        color_map = {"USA": self.colors[0], "China": self.colors[1], "Europe": self.colors[2], "Others": self.colors[3]}
        
        for region, insts in countries.items():
            # 添加国家节点
            G.add_node(region, size=300, type='country')
            node_colors.append(color_map[region])
            node_sizes.append(2000)
            labels.append(region)
            
            # 添加机构节点
            for inst in insts:
                G.add_node(inst, size=100, type='inst')
                node_colors.append(color_map[region]) # 机构颜色跟随国家
                node_sizes.append(600)
                labels.append(inst)
                # 连接机构到国家
                G.add_edge(inst, region, weight=5)

        # 添加跨国合作 (模拟真实合作关系)
        intl_edges = [
            ("NREL", "Tsinghua Univ", 3), ("LBNL", "ETH Zurich", 4),
            ("UCL", "Hong Kong PolyU", 2), ("MIT", "Cambridge", 3),
            ("Tsinghua Univ", "LBNL", 4), ("ETH Zurich", "NUS", 2)
        ]
        for u, v, w in intl_edges:
            if u in G.nodes and v in G.nodes:
                G.add_edge(u, v, weight=w)

        pos = nx.spring_layout(G, k=0.5, iterations=50, seed=10)
        
        # 绘制
        self.draw_network(G, pos, node_colors, node_sizes, labels, ax)
        plt.tight_layout()
        plt.savefig('vosviewer_collab_map.png', dpi=300, facecolor=self.bg_color)

    def generate_cocitation_map(self):
        """生成文献共被引图 (Document Co-citation)"""
        fig, ax = self.setup_plot("VOSviewer Output 3: Document Co-citation Analysis\n(Intellectual Base vs. Research Front)")
        
        # 经典文献 (基础) vs 新兴文献 (前沿)
        # 格式: "FirstAuthor (Year)"
        classics = ["Reinhart (2016)", "Swan (2009)", "Robinson (2009)", "Nouvel (2013)", "Hong T (2016)"]
        middle = ["Sola (2018)", "Chen Y (2017)", "Davila (2016)", "Li X (2019)"]
        front = ["Ang (2020)", "Lu Y (2021)", "Nutkiewicz (2021)", "Niu S (2022)", "Chen T (2023)"]
        
        G = nx.Graph()
        node_colors = []
        node_sizes = []
        
        # 黄色: 经典, 绿色: 过渡, 红色: 前沿 (热点)
        all_papers = classics + middle + front
        
        for p in all_papers:
            if p in classics:
                color = '#FFFF00' # Yellow
                size = 800
            elif p in middle:
                color = '#00FF00' # Green
                size = 600
            else:
                color = '#FF0000' # Red
                size = 500
            
            G.add_node(p, size=size)
            node_colors.append(color)
            node_sizes.append(size)

        # 构建共被引关系
        # 经典文献之间互引高
        for i in range(len(classics)):
            for j in range(i+1, len(classics)):
                G.add_edge(classics[i], classics[j], weight=4)
        
        # 新文献引用旧文献
        for m in middle:
            target = random.choice(classics)
            G.add_edge(m, target, weight=3)
            
        for f in front:
            target_m = random.choice(middle)
            target_c = random.choice(classics)
            G.add_edge(f, target_m, weight=2)
            G.add_edge(f, target_c, weight=1)
            # 前沿文献之间也有关联
            target_f = random.choice(front)
            if f != target_f:
                G.add_edge(f, target_f, weight=2)

        pos = nx.kamada_kawai_layout(G) # 使用不同的布局算法，显示更聚集的效果
        self.draw_network(G, pos, node_colors, node_sizes, all_papers, ax)
        plt.tight_layout()
        plt.savefig('vosviewer_cocitation_map.png', dpi=300, facecolor=self.bg_color)

if __name__ == "__main__":
    sim = VOSviewerSim()
    sim.generate_keyword_map()
    sim.generate_collaboration_map()
    sim.generate_cocitation_map()
    print("VOSviewer simulation images generated successfully.")
